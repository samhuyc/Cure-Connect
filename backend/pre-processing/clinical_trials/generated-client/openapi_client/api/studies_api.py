# coding: utf-8

"""
    ClinicalTrials.gov REST API

    This API is made available to provide users meta data, statistics, and the most recent version of the clinical trials available on ClinicalTrials.gov.

    The version of the OpenAPI document: 2.0.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.enum_info import EnumInfo
from openapi_client.models.field_node import FieldNode
from openapi_client.models.paged_studies import PagedStudies
from openapi_client.models.search_document import SearchDocument
from openapi_client.models.status import Status

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class StudiesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def enums(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[EnumInfo]:
        """Enums

        Returns enumeration types and their values.  Every item of the returning array represents enum type and contains the following properties: * `type` - enum type name * `pieces` - array of names of all data pieces having the enum type * `values` - all available values of the enum; every item contains the following properties:   * `value` - data value   * `legacyValue` - data value in legacy API   * `exceptions` - map from data piece name to legacy value when different from `legacyValue`     (some data pieces had special enum values in legacy API)

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._enums_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EnumInfo]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def enums_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[EnumInfo]]:
        """Enums

        Returns enumeration types and their values.  Every item of the returning array represents enum type and contains the following properties: * `type` - enum type name * `pieces` - array of names of all data pieces having the enum type * `values` - all available values of the enum; every item contains the following properties:   * `value` - data value   * `legacyValue` - data value in legacy API   * `exceptions` - map from data piece name to legacy value when different from `legacyValue`     (some data pieces had special enum values in legacy API)

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._enums_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EnumInfo]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def enums_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Enums

        Returns enumeration types and their values.  Every item of the returning array represents enum type and contains the following properties: * `type` - enum type name * `pieces` - array of names of all data pieces having the enum type * `values` - all available values of the enum; every item contains the following properties:   * `value` - data value   * `legacyValue` - data value in legacy API   * `exceptions` - map from data piece name to legacy value when different from `legacyValue`     (some data pieces had special enum values in legacy API)

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._enums_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EnumInfo]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _enums_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/studies/enums',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_study(
        self,
        nct_id: Annotated[str, Field(strict=True, description="NCT Number of a study. If found in [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) field, 301 HTTP redirect to the actual study will be returned.")],
        format: Annotated[Optional[StrictStr], Field(description="Must be one of the following: * `csv`- return CSV table; available fields are listed on [CSV Download](/data-api/about-api/csv-download) * `json`- return JSON object; format of `markup` fields depends on `markupFormat` parameter * `json.zip`- put JSON object into a .json file and download it as zip archive; field values of type `markup` are in [markdown](https://spec.commonmark.org/0.28/) format * `fhir.json` - return FHIR JSON; fields are not customizable; see [Access Data in FHIR](/data-api/fhir) * `ris`- return RIS record; available tags are listed on [RIS Download](/data-api/about-api/ris-download)")] = None,
        markup_format: Annotated[Optional[StrictStr], Field(description="Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.")] = None,
        fields: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1)]], Field(description="If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` and `json.zip` formats, every list item is either area name, piece name, or field name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names - on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint.  For `fhir.json` format, all available fields are returned and this parameter must be unspecified.  For `ris` format, specify list of tags. The tag names are available on [RIS Download](/data-api/about-api/ris-download).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Single Study

        Returns data of a single study.

        :param nct_id: NCT Number of a study. If found in [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) field, 301 HTTP redirect to the actual study will be returned. (required)
        :type nct_id: str
        :param format: Must be one of the following: * `csv`- return CSV table; available fields are listed on [CSV Download](/data-api/about-api/csv-download) * `json`- return JSON object; format of `markup` fields depends on `markupFormat` parameter * `json.zip`- put JSON object into a .json file and download it as zip archive; field values of type `markup` are in [markdown](https://spec.commonmark.org/0.28/) format * `fhir.json` - return FHIR JSON; fields are not customizable; see [Access Data in FHIR](/data-api/fhir) * `ris`- return RIS record; available tags are listed on [RIS Download](/data-api/about-api/ris-download)
        :type format: str
        :param markup_format: Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.
        :type markup_format: str
        :param fields: If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` and `json.zip` formats, every list item is either area name, piece name, or field name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names - on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint.  For `fhir.json` format, all available fields are returned and this parameter must be unspecified.  For `ris` format, specify list of tags. The tag names are available on [RIS Download](/data-api/about-api/ris-download).
        :type fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_study_serialize(
            nct_id=nct_id,
            format=format,
            markup_format=markup_format,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '301': None,
            '400': "str",
            '404': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_study_with_http_info(
        self,
        nct_id: Annotated[str, Field(strict=True, description="NCT Number of a study. If found in [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) field, 301 HTTP redirect to the actual study will be returned.")],
        format: Annotated[Optional[StrictStr], Field(description="Must be one of the following: * `csv`- return CSV table; available fields are listed on [CSV Download](/data-api/about-api/csv-download) * `json`- return JSON object; format of `markup` fields depends on `markupFormat` parameter * `json.zip`- put JSON object into a .json file and download it as zip archive; field values of type `markup` are in [markdown](https://spec.commonmark.org/0.28/) format * `fhir.json` - return FHIR JSON; fields are not customizable; see [Access Data in FHIR](/data-api/fhir) * `ris`- return RIS record; available tags are listed on [RIS Download](/data-api/about-api/ris-download)")] = None,
        markup_format: Annotated[Optional[StrictStr], Field(description="Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.")] = None,
        fields: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1)]], Field(description="If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` and `json.zip` formats, every list item is either area name, piece name, or field name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names - on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint.  For `fhir.json` format, all available fields are returned and this parameter must be unspecified.  For `ris` format, specify list of tags. The tag names are available on [RIS Download](/data-api/about-api/ris-download).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Single Study

        Returns data of a single study.

        :param nct_id: NCT Number of a study. If found in [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) field, 301 HTTP redirect to the actual study will be returned. (required)
        :type nct_id: str
        :param format: Must be one of the following: * `csv`- return CSV table; available fields are listed on [CSV Download](/data-api/about-api/csv-download) * `json`- return JSON object; format of `markup` fields depends on `markupFormat` parameter * `json.zip`- put JSON object into a .json file and download it as zip archive; field values of type `markup` are in [markdown](https://spec.commonmark.org/0.28/) format * `fhir.json` - return FHIR JSON; fields are not customizable; see [Access Data in FHIR](/data-api/fhir) * `ris`- return RIS record; available tags are listed on [RIS Download](/data-api/about-api/ris-download)
        :type format: str
        :param markup_format: Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.
        :type markup_format: str
        :param fields: If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` and `json.zip` formats, every list item is either area name, piece name, or field name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names - on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint.  For `fhir.json` format, all available fields are returned and this parameter must be unspecified.  For `ris` format, specify list of tags. The tag names are available on [RIS Download](/data-api/about-api/ris-download).
        :type fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_study_serialize(
            nct_id=nct_id,
            format=format,
            markup_format=markup_format,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '301': None,
            '400': "str",
            '404': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_study_without_preload_content(
        self,
        nct_id: Annotated[str, Field(strict=True, description="NCT Number of a study. If found in [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) field, 301 HTTP redirect to the actual study will be returned.")],
        format: Annotated[Optional[StrictStr], Field(description="Must be one of the following: * `csv`- return CSV table; available fields are listed on [CSV Download](/data-api/about-api/csv-download) * `json`- return JSON object; format of `markup` fields depends on `markupFormat` parameter * `json.zip`- put JSON object into a .json file and download it as zip archive; field values of type `markup` are in [markdown](https://spec.commonmark.org/0.28/) format * `fhir.json` - return FHIR JSON; fields are not customizable; see [Access Data in FHIR](/data-api/fhir) * `ris`- return RIS record; available tags are listed on [RIS Download](/data-api/about-api/ris-download)")] = None,
        markup_format: Annotated[Optional[StrictStr], Field(description="Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.")] = None,
        fields: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1)]], Field(description="If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` and `json.zip` formats, every list item is either area name, piece name, or field name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names - on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint.  For `fhir.json` format, all available fields are returned and this parameter must be unspecified.  For `ris` format, specify list of tags. The tag names are available on [RIS Download](/data-api/about-api/ris-download).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Single Study

        Returns data of a single study.

        :param nct_id: NCT Number of a study. If found in [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) field, 301 HTTP redirect to the actual study will be returned. (required)
        :type nct_id: str
        :param format: Must be one of the following: * `csv`- return CSV table; available fields are listed on [CSV Download](/data-api/about-api/csv-download) * `json`- return JSON object; format of `markup` fields depends on `markupFormat` parameter * `json.zip`- put JSON object into a .json file and download it as zip archive; field values of type `markup` are in [markdown](https://spec.commonmark.org/0.28/) format * `fhir.json` - return FHIR JSON; fields are not customizable; see [Access Data in FHIR](/data-api/fhir) * `ris`- return RIS record; available tags are listed on [RIS Download](/data-api/about-api/ris-download)
        :type format: str
        :param markup_format: Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.
        :type markup_format: str
        :param fields: If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` and `json.zip` formats, every list item is either area name, piece name, or field name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names - on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint.  For `fhir.json` format, all available fields are returned and this parameter must be unspecified.  For `ris` format, specify list of tags. The tag names are available on [RIS Download](/data-api/about-api/ris-download).
        :type fields: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_study_serialize(
            nct_id=nct_id,
            format=format,
            markup_format=markup_format,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '301': None,
            '400': "str",
            '404': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_study_serialize(
        self,
        nct_id,
        format,
        markup_format,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'fields': 'pipes',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if nct_id is not None:
            _path_params['nctId'] = nct_id
        # process the query parameters
        if format is not None:
            
            _query_params.append(('format', format))
            
        if markup_format is not None:
            
            _query_params.append(('markupFormat', markup_format))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/csv', 
                    'application/json', 
                    'application/zip', 
                    'application/fhir+json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/studies/{nctId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_studies(
        self,
        format: Annotated[Optional[StrictStr], Field(description="Must be one of the following: * `csv`- return CSV table with one page of study data; first page will contain header with column names; available fields are listed on [CSV Download](/data-api/about-api/csv-download) page * `json`- return JSON with one page of study data; every study object is placed in a separate line; `markup` type fields format depends on `markupFormat` parameter")] = None,
        markup_format: Annotated[Optional[StrictStr], Field(description="Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.")] = None,
        query_cond: Annotated[Optional[StrictStr], Field(description="\"Conditions or disease\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"ConditionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#ConditionSearch) for more details.")] = None,
        query_term: Annotated[Optional[StrictStr], Field(description="\"Other terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"BasicSearch Area\" on [Search Areas](/data-api/about-api/search-areas#BasicSearch) for more details.")] = None,
        query_locn: Annotated[Optional[StrictStr], Field(description="\"Location terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"LocationSearch Area\" on [Search Areas](/data-api/about-api/search-areas#LocationSearch) for more details.")] = None,
        query_titles: Annotated[Optional[StrictStr], Field(description="\"Title / acronym\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"TitleSearch Area\" on [Search Areas](/data-api/about-api/search-areas#TitleSearch) for more details.")] = None,
        query_intr: Annotated[Optional[StrictStr], Field(description="\"Intervention / treatment\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"InterventionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#InterventionSearch) for more details.")] = None,
        query_outc: Annotated[Optional[StrictStr], Field(description="\"Outcome measure\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"OutcomeSearch Area\" on [Search Areas](/data-api/about-api/search-areas#OutcomeSearch) for more details.")] = None,
        query_spons: Annotated[Optional[StrictStr], Field(description="\"Sponsor / collaborator\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"SponsorSearch Area\" on [Search Areas](/data-api/about-api/search-areas#SponsorSearch) for more details.")] = None,
        query_lead: Annotated[Optional[StrictStr], Field(description="Searches in \"LeadSponsorName\" field. See [Study Data Structure](/data-api/about-api/study-data-structure#LeadSponsorName) for more details. The query is in [Essie expression syntax](/find-studies/constructing-complex-search-queries).")] = None,
        query_id: Annotated[Optional[StrictStr], Field(description="\"Study IDs\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"IdSearch Area\" on [Search Areas](/data-api/about-api/search-areas#IdSearch) for more details.")] = None,
        query_patient: Annotated[Optional[StrictStr], Field(description="See \"PatientSearch Area\" on [Search Areas](/data-api/about-api/search-areas#PatientSearch) for more details.")] = None,
        filter_overall_status: Annotated[Optional[List[Status]], Field(description="Filter by comma- or pipe-separated list of statuses")] = None,
        filter_geo: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`")] = None,
        filter_ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.")] = None,
        filter_advanced: Annotated[Optional[StrictStr], Field(description="Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)")] = None,
        filter_synonyms: Annotated[Optional[List[StrictStr]], Field(description="Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs")] = None,
        post_filter_overall_status: Annotated[Optional[List[Status]], Field(description="Filter by comma- or pipe-separated list of statuses")] = None,
        post_filter_geo: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`")] = None,
        post_filter_ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.")] = None,
        post_filter_advanced: Annotated[Optional[StrictStr], Field(description="Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)")] = None,
        post_filter_synonyms: Annotated[Optional[List[StrictStr]], Field(description="Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs")] = None,
        agg_filters: Annotated[Optional[StrictStr], Field(description="Apply aggregation filters, aggregation counts will not be provided. The value is comma- or pipe-separated list of pairs `filter_id`:`space-separated list of option keys` for the checked options.")] = None,
        geo_decay: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Set proximity factor by distance from `filter.geo` location to the closest [LocationGeoPoint](/data-api/about-api/study-data-structure#LocationGeoPoint) of a study. Ignored, if `filter.geo` parameter is not set or response contains more than 10,000 studies.")] = None,
        fields: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1)]], Field(description="If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` format, every list item is either area name, piece name, field name, or special name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names — on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. There is a special name, `@query`, which expands to all fields queried by search.")] = None,
        sort: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(max_length=2)]], Field(description="Comma- or pipe-separated list of sorting options of the studies. The returning studies are not sorted by default for a performance reason. Every list item contains a field/piece name and an optional sort direction (`asc` for ascending or `desc` for descending) after colon character.  All piece and field names can be found on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. Currently, only date and numeric fields are allowed for sorting. There is a special \"field\" `@relevance` to sort by relevance to a search query.  Studies missing sort field are always last. Default sort direction: * Date field - `desc` * Numeric field - `asc` * `@relevance` - `desc`")] = None,
        count_total: Annotated[Optional[StrictBool], Field(description="Count total number of studies in all pages and return `totalCount` field with first page, if `true`. For CSV, the result can be found in `x-total-count` response header. The parameter is ignored for the subsequent pages.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size is maximum number of studies to return in response. It does not have to be the same for every page. If not specified or set to 0, the default value will be used. It will be coerced down to  1,000, if greater than that.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Token to get next page. Set it to a `nextPageToken` value returned with the previous page in JSON format. For CSV, it can be found in `x-next-page-token` response header. Do not specify it for first page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PagedStudies:
        """Studies

        Returns data of studies matching query and filter parameters. The studies are returned page by page. If response contains `nextPageToken`, use its value in `pageToken` to get next page. The last page will not contain `nextPageToken`. A page may have empty `studies` array. Request for each subsequent page **must** have the same parameters as for the first page, except `countTotal`, `pageSize`, and `pageToken` parameters.  If neither queries nor filters are set, all studies will be returned. If any query parameter contains only NCT IDs (comma- and/or space-separated), filters are ignored.  `query.*` parameters are in [Essie expression syntax](/find-studies/constructing-complex-search-queries). Those parameters affect ranking of studies, if sorted by relevance. See `sort` parameter for details.  `filter.*` and `postFilter.*` parameters have same effect as there is no aggregation calculation.  Both are available just to simplify applying parameters from search request. Both do not affect ranking of studies.  Note: When trying JSON format in your browser, do not set too large `pageSize` parameter, if `fields` is unlimited. That may return too much data for the browser to parse and render.

        :param format: Must be one of the following: * `csv`- return CSV table with one page of study data; first page will contain header with column names; available fields are listed on [CSV Download](/data-api/about-api/csv-download) page * `json`- return JSON with one page of study data; every study object is placed in a separate line; `markup` type fields format depends on `markupFormat` parameter
        :type format: str
        :param markup_format: Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.
        :type markup_format: str
        :param query_cond: \"Conditions or disease\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"ConditionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#ConditionSearch) for more details.
        :type query_cond: str
        :param query_term: \"Other terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"BasicSearch Area\" on [Search Areas](/data-api/about-api/search-areas#BasicSearch) for more details.
        :type query_term: str
        :param query_locn: \"Location terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"LocationSearch Area\" on [Search Areas](/data-api/about-api/search-areas#LocationSearch) for more details.
        :type query_locn: str
        :param query_titles: \"Title / acronym\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"TitleSearch Area\" on [Search Areas](/data-api/about-api/search-areas#TitleSearch) for more details.
        :type query_titles: str
        :param query_intr: \"Intervention / treatment\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"InterventionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#InterventionSearch) for more details.
        :type query_intr: str
        :param query_outc: \"Outcome measure\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"OutcomeSearch Area\" on [Search Areas](/data-api/about-api/search-areas#OutcomeSearch) for more details.
        :type query_outc: str
        :param query_spons: \"Sponsor / collaborator\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"SponsorSearch Area\" on [Search Areas](/data-api/about-api/search-areas#SponsorSearch) for more details.
        :type query_spons: str
        :param query_lead: Searches in \"LeadSponsorName\" field. See [Study Data Structure](/data-api/about-api/study-data-structure#LeadSponsorName) for more details. The query is in [Essie expression syntax](/find-studies/constructing-complex-search-queries).
        :type query_lead: str
        :param query_id: \"Study IDs\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"IdSearch Area\" on [Search Areas](/data-api/about-api/search-areas#IdSearch) for more details.
        :type query_id: str
        :param query_patient: See \"PatientSearch Area\" on [Search Areas](/data-api/about-api/search-areas#PatientSearch) for more details.
        :type query_patient: str
        :param filter_overall_status: Filter by comma- or pipe-separated list of statuses
        :type filter_overall_status: List[Status]
        :param filter_geo: Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`
        :type filter_geo: str
        :param filter_ids: Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.
        :type filter_ids: List[str]
        :param filter_advanced: Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)
        :type filter_advanced: str
        :param filter_synonyms: Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs
        :type filter_synonyms: List[str]
        :param post_filter_overall_status: Filter by comma- or pipe-separated list of statuses
        :type post_filter_overall_status: List[Status]
        :param post_filter_geo: Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`
        :type post_filter_geo: str
        :param post_filter_ids: Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.
        :type post_filter_ids: List[str]
        :param post_filter_advanced: Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)
        :type post_filter_advanced: str
        :param post_filter_synonyms: Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs
        :type post_filter_synonyms: List[str]
        :param agg_filters: Apply aggregation filters, aggregation counts will not be provided. The value is comma- or pipe-separated list of pairs `filter_id`:`space-separated list of option keys` for the checked options.
        :type agg_filters: str
        :param geo_decay: Set proximity factor by distance from `filter.geo` location to the closest [LocationGeoPoint](/data-api/about-api/study-data-structure#LocationGeoPoint) of a study. Ignored, if `filter.geo` parameter is not set or response contains more than 10,000 studies.
        :type geo_decay: str
        :param fields: If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` format, every list item is either area name, piece name, field name, or special name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names — on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. There is a special name, `@query`, which expands to all fields queried by search.
        :type fields: List[str]
        :param sort: Comma- or pipe-separated list of sorting options of the studies. The returning studies are not sorted by default for a performance reason. Every list item contains a field/piece name and an optional sort direction (`asc` for ascending or `desc` for descending) after colon character.  All piece and field names can be found on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. Currently, only date and numeric fields are allowed for sorting. There is a special \"field\" `@relevance` to sort by relevance to a search query.  Studies missing sort field are always last. Default sort direction: * Date field - `desc` * Numeric field - `asc` * `@relevance` - `desc`
        :type sort: List[str]
        :param count_total: Count total number of studies in all pages and return `totalCount` field with first page, if `true`. For CSV, the result can be found in `x-total-count` response header. The parameter is ignored for the subsequent pages.
        :type count_total: bool
        :param page_size: Page size is maximum number of studies to return in response. It does not have to be the same for every page. If not specified or set to 0, the default value will be used. It will be coerced down to  1,000, if greater than that.
        :type page_size: int
        :param page_token: Token to get next page. Set it to a `nextPageToken` value returned with the previous page in JSON format. For CSV, it can be found in `x-next-page-token` response header. Do not specify it for first page.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_studies_serialize(
            format=format,
            markup_format=markup_format,
            query_cond=query_cond,
            query_term=query_term,
            query_locn=query_locn,
            query_titles=query_titles,
            query_intr=query_intr,
            query_outc=query_outc,
            query_spons=query_spons,
            query_lead=query_lead,
            query_id=query_id,
            query_patient=query_patient,
            filter_overall_status=filter_overall_status,
            filter_geo=filter_geo,
            filter_ids=filter_ids,
            filter_advanced=filter_advanced,
            filter_synonyms=filter_synonyms,
            post_filter_overall_status=post_filter_overall_status,
            post_filter_geo=post_filter_geo,
            post_filter_ids=post_filter_ids,
            post_filter_advanced=post_filter_advanced,
            post_filter_synonyms=post_filter_synonyms,
            agg_filters=agg_filters,
            geo_decay=geo_decay,
            fields=fields,
            sort=sort,
            count_total=count_total,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedStudies",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_studies_with_http_info(
        self,
        format: Annotated[Optional[StrictStr], Field(description="Must be one of the following: * `csv`- return CSV table with one page of study data; first page will contain header with column names; available fields are listed on [CSV Download](/data-api/about-api/csv-download) page * `json`- return JSON with one page of study data; every study object is placed in a separate line; `markup` type fields format depends on `markupFormat` parameter")] = None,
        markup_format: Annotated[Optional[StrictStr], Field(description="Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.")] = None,
        query_cond: Annotated[Optional[StrictStr], Field(description="\"Conditions or disease\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"ConditionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#ConditionSearch) for more details.")] = None,
        query_term: Annotated[Optional[StrictStr], Field(description="\"Other terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"BasicSearch Area\" on [Search Areas](/data-api/about-api/search-areas#BasicSearch) for more details.")] = None,
        query_locn: Annotated[Optional[StrictStr], Field(description="\"Location terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"LocationSearch Area\" on [Search Areas](/data-api/about-api/search-areas#LocationSearch) for more details.")] = None,
        query_titles: Annotated[Optional[StrictStr], Field(description="\"Title / acronym\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"TitleSearch Area\" on [Search Areas](/data-api/about-api/search-areas#TitleSearch) for more details.")] = None,
        query_intr: Annotated[Optional[StrictStr], Field(description="\"Intervention / treatment\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"InterventionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#InterventionSearch) for more details.")] = None,
        query_outc: Annotated[Optional[StrictStr], Field(description="\"Outcome measure\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"OutcomeSearch Area\" on [Search Areas](/data-api/about-api/search-areas#OutcomeSearch) for more details.")] = None,
        query_spons: Annotated[Optional[StrictStr], Field(description="\"Sponsor / collaborator\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"SponsorSearch Area\" on [Search Areas](/data-api/about-api/search-areas#SponsorSearch) for more details.")] = None,
        query_lead: Annotated[Optional[StrictStr], Field(description="Searches in \"LeadSponsorName\" field. See [Study Data Structure](/data-api/about-api/study-data-structure#LeadSponsorName) for more details. The query is in [Essie expression syntax](/find-studies/constructing-complex-search-queries).")] = None,
        query_id: Annotated[Optional[StrictStr], Field(description="\"Study IDs\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"IdSearch Area\" on [Search Areas](/data-api/about-api/search-areas#IdSearch) for more details.")] = None,
        query_patient: Annotated[Optional[StrictStr], Field(description="See \"PatientSearch Area\" on [Search Areas](/data-api/about-api/search-areas#PatientSearch) for more details.")] = None,
        filter_overall_status: Annotated[Optional[List[Status]], Field(description="Filter by comma- or pipe-separated list of statuses")] = None,
        filter_geo: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`")] = None,
        filter_ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.")] = None,
        filter_advanced: Annotated[Optional[StrictStr], Field(description="Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)")] = None,
        filter_synonyms: Annotated[Optional[List[StrictStr]], Field(description="Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs")] = None,
        post_filter_overall_status: Annotated[Optional[List[Status]], Field(description="Filter by comma- or pipe-separated list of statuses")] = None,
        post_filter_geo: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`")] = None,
        post_filter_ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.")] = None,
        post_filter_advanced: Annotated[Optional[StrictStr], Field(description="Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)")] = None,
        post_filter_synonyms: Annotated[Optional[List[StrictStr]], Field(description="Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs")] = None,
        agg_filters: Annotated[Optional[StrictStr], Field(description="Apply aggregation filters, aggregation counts will not be provided. The value is comma- or pipe-separated list of pairs `filter_id`:`space-separated list of option keys` for the checked options.")] = None,
        geo_decay: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Set proximity factor by distance from `filter.geo` location to the closest [LocationGeoPoint](/data-api/about-api/study-data-structure#LocationGeoPoint) of a study. Ignored, if `filter.geo` parameter is not set or response contains more than 10,000 studies.")] = None,
        fields: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1)]], Field(description="If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` format, every list item is either area name, piece name, field name, or special name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names — on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. There is a special name, `@query`, which expands to all fields queried by search.")] = None,
        sort: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(max_length=2)]], Field(description="Comma- or pipe-separated list of sorting options of the studies. The returning studies are not sorted by default for a performance reason. Every list item contains a field/piece name and an optional sort direction (`asc` for ascending or `desc` for descending) after colon character.  All piece and field names can be found on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. Currently, only date and numeric fields are allowed for sorting. There is a special \"field\" `@relevance` to sort by relevance to a search query.  Studies missing sort field are always last. Default sort direction: * Date field - `desc` * Numeric field - `asc` * `@relevance` - `desc`")] = None,
        count_total: Annotated[Optional[StrictBool], Field(description="Count total number of studies in all pages and return `totalCount` field with first page, if `true`. For CSV, the result can be found in `x-total-count` response header. The parameter is ignored for the subsequent pages.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size is maximum number of studies to return in response. It does not have to be the same for every page. If not specified or set to 0, the default value will be used. It will be coerced down to  1,000, if greater than that.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Token to get next page. Set it to a `nextPageToken` value returned with the previous page in JSON format. For CSV, it can be found in `x-next-page-token` response header. Do not specify it for first page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PagedStudies]:
        """Studies

        Returns data of studies matching query and filter parameters. The studies are returned page by page. If response contains `nextPageToken`, use its value in `pageToken` to get next page. The last page will not contain `nextPageToken`. A page may have empty `studies` array. Request for each subsequent page **must** have the same parameters as for the first page, except `countTotal`, `pageSize`, and `pageToken` parameters.  If neither queries nor filters are set, all studies will be returned. If any query parameter contains only NCT IDs (comma- and/or space-separated), filters are ignored.  `query.*` parameters are in [Essie expression syntax](/find-studies/constructing-complex-search-queries). Those parameters affect ranking of studies, if sorted by relevance. See `sort` parameter for details.  `filter.*` and `postFilter.*` parameters have same effect as there is no aggregation calculation.  Both are available just to simplify applying parameters from search request. Both do not affect ranking of studies.  Note: When trying JSON format in your browser, do not set too large `pageSize` parameter, if `fields` is unlimited. That may return too much data for the browser to parse and render.

        :param format: Must be one of the following: * `csv`- return CSV table with one page of study data; first page will contain header with column names; available fields are listed on [CSV Download](/data-api/about-api/csv-download) page * `json`- return JSON with one page of study data; every study object is placed in a separate line; `markup` type fields format depends on `markupFormat` parameter
        :type format: str
        :param markup_format: Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.
        :type markup_format: str
        :param query_cond: \"Conditions or disease\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"ConditionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#ConditionSearch) for more details.
        :type query_cond: str
        :param query_term: \"Other terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"BasicSearch Area\" on [Search Areas](/data-api/about-api/search-areas#BasicSearch) for more details.
        :type query_term: str
        :param query_locn: \"Location terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"LocationSearch Area\" on [Search Areas](/data-api/about-api/search-areas#LocationSearch) for more details.
        :type query_locn: str
        :param query_titles: \"Title / acronym\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"TitleSearch Area\" on [Search Areas](/data-api/about-api/search-areas#TitleSearch) for more details.
        :type query_titles: str
        :param query_intr: \"Intervention / treatment\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"InterventionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#InterventionSearch) for more details.
        :type query_intr: str
        :param query_outc: \"Outcome measure\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"OutcomeSearch Area\" on [Search Areas](/data-api/about-api/search-areas#OutcomeSearch) for more details.
        :type query_outc: str
        :param query_spons: \"Sponsor / collaborator\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"SponsorSearch Area\" on [Search Areas](/data-api/about-api/search-areas#SponsorSearch) for more details.
        :type query_spons: str
        :param query_lead: Searches in \"LeadSponsorName\" field. See [Study Data Structure](/data-api/about-api/study-data-structure#LeadSponsorName) for more details. The query is in [Essie expression syntax](/find-studies/constructing-complex-search-queries).
        :type query_lead: str
        :param query_id: \"Study IDs\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"IdSearch Area\" on [Search Areas](/data-api/about-api/search-areas#IdSearch) for more details.
        :type query_id: str
        :param query_patient: See \"PatientSearch Area\" on [Search Areas](/data-api/about-api/search-areas#PatientSearch) for more details.
        :type query_patient: str
        :param filter_overall_status: Filter by comma- or pipe-separated list of statuses
        :type filter_overall_status: List[Status]
        :param filter_geo: Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`
        :type filter_geo: str
        :param filter_ids: Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.
        :type filter_ids: List[str]
        :param filter_advanced: Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)
        :type filter_advanced: str
        :param filter_synonyms: Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs
        :type filter_synonyms: List[str]
        :param post_filter_overall_status: Filter by comma- or pipe-separated list of statuses
        :type post_filter_overall_status: List[Status]
        :param post_filter_geo: Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`
        :type post_filter_geo: str
        :param post_filter_ids: Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.
        :type post_filter_ids: List[str]
        :param post_filter_advanced: Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)
        :type post_filter_advanced: str
        :param post_filter_synonyms: Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs
        :type post_filter_synonyms: List[str]
        :param agg_filters: Apply aggregation filters, aggregation counts will not be provided. The value is comma- or pipe-separated list of pairs `filter_id`:`space-separated list of option keys` for the checked options.
        :type agg_filters: str
        :param geo_decay: Set proximity factor by distance from `filter.geo` location to the closest [LocationGeoPoint](/data-api/about-api/study-data-structure#LocationGeoPoint) of a study. Ignored, if `filter.geo` parameter is not set or response contains more than 10,000 studies.
        :type geo_decay: str
        :param fields: If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` format, every list item is either area name, piece name, field name, or special name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names — on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. There is a special name, `@query`, which expands to all fields queried by search.
        :type fields: List[str]
        :param sort: Comma- or pipe-separated list of sorting options of the studies. The returning studies are not sorted by default for a performance reason. Every list item contains a field/piece name and an optional sort direction (`asc` for ascending or `desc` for descending) after colon character.  All piece and field names can be found on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. Currently, only date and numeric fields are allowed for sorting. There is a special \"field\" `@relevance` to sort by relevance to a search query.  Studies missing sort field are always last. Default sort direction: * Date field - `desc` * Numeric field - `asc` * `@relevance` - `desc`
        :type sort: List[str]
        :param count_total: Count total number of studies in all pages and return `totalCount` field with first page, if `true`. For CSV, the result can be found in `x-total-count` response header. The parameter is ignored for the subsequent pages.
        :type count_total: bool
        :param page_size: Page size is maximum number of studies to return in response. It does not have to be the same for every page. If not specified or set to 0, the default value will be used. It will be coerced down to  1,000, if greater than that.
        :type page_size: int
        :param page_token: Token to get next page. Set it to a `nextPageToken` value returned with the previous page in JSON format. For CSV, it can be found in `x-next-page-token` response header. Do not specify it for first page.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_studies_serialize(
            format=format,
            markup_format=markup_format,
            query_cond=query_cond,
            query_term=query_term,
            query_locn=query_locn,
            query_titles=query_titles,
            query_intr=query_intr,
            query_outc=query_outc,
            query_spons=query_spons,
            query_lead=query_lead,
            query_id=query_id,
            query_patient=query_patient,
            filter_overall_status=filter_overall_status,
            filter_geo=filter_geo,
            filter_ids=filter_ids,
            filter_advanced=filter_advanced,
            filter_synonyms=filter_synonyms,
            post_filter_overall_status=post_filter_overall_status,
            post_filter_geo=post_filter_geo,
            post_filter_ids=post_filter_ids,
            post_filter_advanced=post_filter_advanced,
            post_filter_synonyms=post_filter_synonyms,
            agg_filters=agg_filters,
            geo_decay=geo_decay,
            fields=fields,
            sort=sort,
            count_total=count_total,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedStudies",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_studies_without_preload_content(
        self,
        format: Annotated[Optional[StrictStr], Field(description="Must be one of the following: * `csv`- return CSV table with one page of study data; first page will contain header with column names; available fields are listed on [CSV Download](/data-api/about-api/csv-download) page * `json`- return JSON with one page of study data; every study object is placed in a separate line; `markup` type fields format depends on `markupFormat` parameter")] = None,
        markup_format: Annotated[Optional[StrictStr], Field(description="Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.")] = None,
        query_cond: Annotated[Optional[StrictStr], Field(description="\"Conditions or disease\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"ConditionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#ConditionSearch) for more details.")] = None,
        query_term: Annotated[Optional[StrictStr], Field(description="\"Other terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"BasicSearch Area\" on [Search Areas](/data-api/about-api/search-areas#BasicSearch) for more details.")] = None,
        query_locn: Annotated[Optional[StrictStr], Field(description="\"Location terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"LocationSearch Area\" on [Search Areas](/data-api/about-api/search-areas#LocationSearch) for more details.")] = None,
        query_titles: Annotated[Optional[StrictStr], Field(description="\"Title / acronym\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"TitleSearch Area\" on [Search Areas](/data-api/about-api/search-areas#TitleSearch) for more details.")] = None,
        query_intr: Annotated[Optional[StrictStr], Field(description="\"Intervention / treatment\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"InterventionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#InterventionSearch) for more details.")] = None,
        query_outc: Annotated[Optional[StrictStr], Field(description="\"Outcome measure\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"OutcomeSearch Area\" on [Search Areas](/data-api/about-api/search-areas#OutcomeSearch) for more details.")] = None,
        query_spons: Annotated[Optional[StrictStr], Field(description="\"Sponsor / collaborator\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"SponsorSearch Area\" on [Search Areas](/data-api/about-api/search-areas#SponsorSearch) for more details.")] = None,
        query_lead: Annotated[Optional[StrictStr], Field(description="Searches in \"LeadSponsorName\" field. See [Study Data Structure](/data-api/about-api/study-data-structure#LeadSponsorName) for more details. The query is in [Essie expression syntax](/find-studies/constructing-complex-search-queries).")] = None,
        query_id: Annotated[Optional[StrictStr], Field(description="\"Study IDs\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"IdSearch Area\" on [Search Areas](/data-api/about-api/search-areas#IdSearch) for more details.")] = None,
        query_patient: Annotated[Optional[StrictStr], Field(description="See \"PatientSearch Area\" on [Search Areas](/data-api/about-api/search-areas#PatientSearch) for more details.")] = None,
        filter_overall_status: Annotated[Optional[List[Status]], Field(description="Filter by comma- or pipe-separated list of statuses")] = None,
        filter_geo: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`")] = None,
        filter_ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.")] = None,
        filter_advanced: Annotated[Optional[StrictStr], Field(description="Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)")] = None,
        filter_synonyms: Annotated[Optional[List[StrictStr]], Field(description="Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs")] = None,
        post_filter_overall_status: Annotated[Optional[List[Status]], Field(description="Filter by comma- or pipe-separated list of statuses")] = None,
        post_filter_geo: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`")] = None,
        post_filter_ids: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.")] = None,
        post_filter_advanced: Annotated[Optional[StrictStr], Field(description="Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)")] = None,
        post_filter_synonyms: Annotated[Optional[List[StrictStr]], Field(description="Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs")] = None,
        agg_filters: Annotated[Optional[StrictStr], Field(description="Apply aggregation filters, aggregation counts will not be provided. The value is comma- or pipe-separated list of pairs `filter_id`:`space-separated list of option keys` for the checked options.")] = None,
        geo_decay: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Set proximity factor by distance from `filter.geo` location to the closest [LocationGeoPoint](/data-api/about-api/study-data-structure#LocationGeoPoint) of a study. Ignored, if `filter.geo` parameter is not set or response contains more than 10,000 studies.")] = None,
        fields: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(min_length=1)]], Field(description="If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` format, every list item is either area name, piece name, field name, or special name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names — on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. There is a special name, `@query`, which expands to all fields queried by search.")] = None,
        sort: Annotated[Optional[Annotated[List[Annotated[str, Field(strict=True)]], Field(max_length=2)]], Field(description="Comma- or pipe-separated list of sorting options of the studies. The returning studies are not sorted by default for a performance reason. Every list item contains a field/piece name and an optional sort direction (`asc` for ascending or `desc` for descending) after colon character.  All piece and field names can be found on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. Currently, only date and numeric fields are allowed for sorting. There is a special \"field\" `@relevance` to sort by relevance to a search query.  Studies missing sort field are always last. Default sort direction: * Date field - `desc` * Numeric field - `asc` * `@relevance` - `desc`")] = None,
        count_total: Annotated[Optional[StrictBool], Field(description="Count total number of studies in all pages and return `totalCount` field with first page, if `true`. For CSV, the result can be found in `x-total-count` response header. The parameter is ignored for the subsequent pages.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page size is maximum number of studies to return in response. It does not have to be the same for every page. If not specified or set to 0, the default value will be used. It will be coerced down to  1,000, if greater than that.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Token to get next page. Set it to a `nextPageToken` value returned with the previous page in JSON format. For CSV, it can be found in `x-next-page-token` response header. Do not specify it for first page.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Studies

        Returns data of studies matching query and filter parameters. The studies are returned page by page. If response contains `nextPageToken`, use its value in `pageToken` to get next page. The last page will not contain `nextPageToken`. A page may have empty `studies` array. Request for each subsequent page **must** have the same parameters as for the first page, except `countTotal`, `pageSize`, and `pageToken` parameters.  If neither queries nor filters are set, all studies will be returned. If any query parameter contains only NCT IDs (comma- and/or space-separated), filters are ignored.  `query.*` parameters are in [Essie expression syntax](/find-studies/constructing-complex-search-queries). Those parameters affect ranking of studies, if sorted by relevance. See `sort` parameter for details.  `filter.*` and `postFilter.*` parameters have same effect as there is no aggregation calculation.  Both are available just to simplify applying parameters from search request. Both do not affect ranking of studies.  Note: When trying JSON format in your browser, do not set too large `pageSize` parameter, if `fields` is unlimited. That may return too much data for the browser to parse and render.

        :param format: Must be one of the following: * `csv`- return CSV table with one page of study data; first page will contain header with column names; available fields are listed on [CSV Download](/data-api/about-api/csv-download) page * `json`- return JSON with one page of study data; every study object is placed in a separate line; `markup` type fields format depends on `markupFormat` parameter
        :type format: str
        :param markup_format: Format of `markup` type fields: * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format * `legacy`- compatible with classic PRS  Applicable only to `json` format.
        :type markup_format: str
        :param query_cond: \"Conditions or disease\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"ConditionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#ConditionSearch) for more details.
        :type query_cond: str
        :param query_term: \"Other terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"BasicSearch Area\" on [Search Areas](/data-api/about-api/search-areas#BasicSearch) for more details.
        :type query_term: str
        :param query_locn: \"Location terms\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"LocationSearch Area\" on [Search Areas](/data-api/about-api/search-areas#LocationSearch) for more details.
        :type query_locn: str
        :param query_titles: \"Title / acronym\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"TitleSearch Area\" on [Search Areas](/data-api/about-api/search-areas#TitleSearch) for more details.
        :type query_titles: str
        :param query_intr: \"Intervention / treatment\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"InterventionSearch Area\" on [Search Areas](/data-api/about-api/search-areas#InterventionSearch) for more details.
        :type query_intr: str
        :param query_outc: \"Outcome measure\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"OutcomeSearch Area\" on [Search Areas](/data-api/about-api/search-areas#OutcomeSearch) for more details.
        :type query_outc: str
        :param query_spons: \"Sponsor / collaborator\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"SponsorSearch Area\" on [Search Areas](/data-api/about-api/search-areas#SponsorSearch) for more details.
        :type query_spons: str
        :param query_lead: Searches in \"LeadSponsorName\" field. See [Study Data Structure](/data-api/about-api/study-data-structure#LeadSponsorName) for more details. The query is in [Essie expression syntax](/find-studies/constructing-complex-search-queries).
        :type query_lead: str
        :param query_id: \"Study IDs\" query in [Essie expression syntax](/find-studies/constructing-complex-search-queries). See \"IdSearch Area\" on [Search Areas](/data-api/about-api/search-areas#IdSearch) for more details.
        :type query_id: str
        :param query_patient: See \"PatientSearch Area\" on [Search Areas](/data-api/about-api/search-areas#PatientSearch) for more details.
        :type query_patient: str
        :param filter_overall_status: Filter by comma- or pipe-separated list of statuses
        :type filter_overall_status: List[Status]
        :param filter_geo: Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`
        :type filter_geo: str
        :param filter_ids: Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.
        :type filter_ids: List[str]
        :param filter_advanced: Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)
        :type filter_advanced: str
        :param filter_synonyms: Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs
        :type filter_synonyms: List[str]
        :param post_filter_overall_status: Filter by comma- or pipe-separated list of statuses
        :type post_filter_overall_status: List[Status]
        :param post_filter_geo: Filter by geo-function. Currently only distance function is supported. Format: `distance(latitude,longitude,distance)`
        :type post_filter_geo: str
        :param post_filter_ids: Filter by comma- or pipe-separated list of NCT IDs (a.k.a. ClinicalTrials.gov identifiers). The provided IDs will be searched in [NCTId](data-api/about-api/study-data-structure#NCTId) and [NCTIdAlias](data-api/about-api/study-data-structure#NCTIdAlias) fields.
        :type post_filter_ids: List[str]
        :param post_filter_advanced: Filter by query in [Essie expression syntax](/find-studies/constructing-complex-search-queries)
        :type post_filter_advanced: str
        :param post_filter_synonyms: Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs
        :type post_filter_synonyms: List[str]
        :param agg_filters: Apply aggregation filters, aggregation counts will not be provided. The value is comma- or pipe-separated list of pairs `filter_id`:`space-separated list of option keys` for the checked options.
        :type agg_filters: str
        :param geo_decay: Set proximity factor by distance from `filter.geo` location to the closest [LocationGeoPoint](/data-api/about-api/study-data-structure#LocationGeoPoint) of a study. Ignored, if `filter.geo` parameter is not set or response contains more than 10,000 studies.
        :type geo_decay: str
        :param fields: If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned. Order of the fields does not matter.  For `csv` format, specify list of columns. The column names are available on [CSV Download](/data-api/about-api/csv-download).  For `json` format, every list item is either area name, piece name, field name, or special name. If a piece or a field is a branch node, all descendant fields will be included. All area names are available on [Search Areas](/data-api/about-api/search-areas), the piece and field names — on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. There is a special name, `@query`, which expands to all fields queried by search.
        :type fields: List[str]
        :param sort: Comma- or pipe-separated list of sorting options of the studies. The returning studies are not sorted by default for a performance reason. Every list item contains a field/piece name and an optional sort direction (`asc` for ascending or `desc` for descending) after colon character.  All piece and field names can be found on [Data Structure](/data-api/about-api/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint. Currently, only date and numeric fields are allowed for sorting. There is a special \"field\" `@relevance` to sort by relevance to a search query.  Studies missing sort field are always last. Default sort direction: * Date field - `desc` * Numeric field - `asc` * `@relevance` - `desc`
        :type sort: List[str]
        :param count_total: Count total number of studies in all pages and return `totalCount` field with first page, if `true`. For CSV, the result can be found in `x-total-count` response header. The parameter is ignored for the subsequent pages.
        :type count_total: bool
        :param page_size: Page size is maximum number of studies to return in response. It does not have to be the same for every page. If not specified or set to 0, the default value will be used. It will be coerced down to  1,000, if greater than that.
        :type page_size: int
        :param page_token: Token to get next page. Set it to a `nextPageToken` value returned with the previous page in JSON format. For CSV, it can be found in `x-next-page-token` response header. Do not specify it for first page.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_studies_serialize(
            format=format,
            markup_format=markup_format,
            query_cond=query_cond,
            query_term=query_term,
            query_locn=query_locn,
            query_titles=query_titles,
            query_intr=query_intr,
            query_outc=query_outc,
            query_spons=query_spons,
            query_lead=query_lead,
            query_id=query_id,
            query_patient=query_patient,
            filter_overall_status=filter_overall_status,
            filter_geo=filter_geo,
            filter_ids=filter_ids,
            filter_advanced=filter_advanced,
            filter_synonyms=filter_synonyms,
            post_filter_overall_status=post_filter_overall_status,
            post_filter_geo=post_filter_geo,
            post_filter_ids=post_filter_ids,
            post_filter_advanced=post_filter_advanced,
            post_filter_synonyms=post_filter_synonyms,
            agg_filters=agg_filters,
            geo_decay=geo_decay,
            fields=fields,
            sort=sort,
            count_total=count_total,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedStudies",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_studies_serialize(
        self,
        format,
        markup_format,
        query_cond,
        query_term,
        query_locn,
        query_titles,
        query_intr,
        query_outc,
        query_spons,
        query_lead,
        query_id,
        query_patient,
        filter_overall_status,
        filter_geo,
        filter_ids,
        filter_advanced,
        filter_synonyms,
        post_filter_overall_status,
        post_filter_geo,
        post_filter_ids,
        post_filter_advanced,
        post_filter_synonyms,
        agg_filters,
        geo_decay,
        fields,
        sort,
        count_total,
        page_size,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filter.overallStatus': 'pipes',
            'filter.ids': 'pipes',
            'filter.synonyms': 'pipes',
            'postFilter.overallStatus': 'pipes',
            'postFilter.ids': 'pipes',
            'postFilter.synonyms': 'pipes',
            'fields': 'pipes',
            'sort': 'pipes',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if format is not None:
            
            _query_params.append(('format', format))
            
        if markup_format is not None:
            
            _query_params.append(('markupFormat', markup_format))
            
        if query_cond is not None:
            
            _query_params.append(('query.cond', query_cond))
            
        if query_term is not None:
            
            _query_params.append(('query.term', query_term))
            
        if query_locn is not None:
            
            _query_params.append(('query.locn', query_locn))
            
        if query_titles is not None:
            
            _query_params.append(('query.titles', query_titles))
            
        if query_intr is not None:
            
            _query_params.append(('query.intr', query_intr))
            
        if query_outc is not None:
            
            _query_params.append(('query.outc', query_outc))
            
        if query_spons is not None:
            
            _query_params.append(('query.spons', query_spons))
            
        if query_lead is not None:
            
            _query_params.append(('query.lead', query_lead))
            
        if query_id is not None:
            
            _query_params.append(('query.id', query_id))
            
        if query_patient is not None:
            
            _query_params.append(('query.patient', query_patient))
            
        if filter_overall_status is not None:
            
            _query_params.append(('filter.overallStatus', filter_overall_status))
            
        if filter_geo is not None:
            
            _query_params.append(('filter.geo', filter_geo))
            
        if filter_ids is not None:
            
            _query_params.append(('filter.ids', filter_ids))
            
        if filter_advanced is not None:
            
            _query_params.append(('filter.advanced', filter_advanced))
            
        if filter_synonyms is not None:
            
            _query_params.append(('filter.synonyms', filter_synonyms))
            
        if post_filter_overall_status is not None:
            
            _query_params.append(('postFilter.overallStatus', post_filter_overall_status))
            
        if post_filter_geo is not None:
            
            _query_params.append(('postFilter.geo', post_filter_geo))
            
        if post_filter_ids is not None:
            
            _query_params.append(('postFilter.ids', post_filter_ids))
            
        if post_filter_advanced is not None:
            
            _query_params.append(('postFilter.advanced', post_filter_advanced))
            
        if post_filter_synonyms is not None:
            
            _query_params.append(('postFilter.synonyms', post_filter_synonyms))
            
        if agg_filters is not None:
            
            _query_params.append(('aggFilters', agg_filters))
            
        if geo_decay is not None:
            
            _query_params.append(('geoDecay', geo_decay))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if count_total is not None:
            
            _query_params.append(('countTotal', count_total))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/studies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_areas(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SearchDocument]:
        """Search Areas

        Search Docs and their Search Areas.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_areas_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchDocument]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_areas_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SearchDocument]]:
        """Search Areas

        Search Docs and their Search Areas.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_areas_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchDocument]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_areas_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Areas

        Search Docs and their Search Areas.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_areas_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchDocument]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_areas_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/studies/search-areas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def studies_metadata(
        self,
        include_indexed_only: Annotated[Optional[StrictBool], Field(description="Include indexed-only fields, if `true`")] = None,
        include_historic_only: Annotated[Optional[StrictBool], Field(description="Include fields available only in historic data, if `true`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FieldNode]:
        """Data Model Fields

        Returns study data model fields.

        :param include_indexed_only: Include indexed-only fields, if `true`
        :type include_indexed_only: bool
        :param include_historic_only: Include fields available only in historic data, if `true`
        :type include_historic_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._studies_metadata_serialize(
            include_indexed_only=include_indexed_only,
            include_historic_only=include_historic_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FieldNode]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def studies_metadata_with_http_info(
        self,
        include_indexed_only: Annotated[Optional[StrictBool], Field(description="Include indexed-only fields, if `true`")] = None,
        include_historic_only: Annotated[Optional[StrictBool], Field(description="Include fields available only in historic data, if `true`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FieldNode]]:
        """Data Model Fields

        Returns study data model fields.

        :param include_indexed_only: Include indexed-only fields, if `true`
        :type include_indexed_only: bool
        :param include_historic_only: Include fields available only in historic data, if `true`
        :type include_historic_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._studies_metadata_serialize(
            include_indexed_only=include_indexed_only,
            include_historic_only=include_historic_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FieldNode]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def studies_metadata_without_preload_content(
        self,
        include_indexed_only: Annotated[Optional[StrictBool], Field(description="Include indexed-only fields, if `true`")] = None,
        include_historic_only: Annotated[Optional[StrictBool], Field(description="Include fields available only in historic data, if `true`")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Data Model Fields

        Returns study data model fields.

        :param include_indexed_only: Include indexed-only fields, if `true`
        :type include_indexed_only: bool
        :param include_historic_only: Include fields available only in historic data, if `true`
        :type include_historic_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._studies_metadata_serialize(
            include_indexed_only=include_indexed_only,
            include_historic_only=include_historic_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FieldNode]",
            '400': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _studies_metadata_serialize(
        self,
        include_indexed_only,
        include_historic_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include_indexed_only is not None:
            
            _query_params.append(('includeIndexedOnly', include_indexed_only))
            
        if include_historic_only is not None:
            
            _query_params.append(('includeHistoricOnly', include_historic_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/studies/metadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


